
--==-- ItemBasicInfoDB3 Functionality Description --==--

Addon type: Library
Libraries used:
	EventsManager2

This addon is an item information database. It maintains the following data about item links:
type, subtype, equip location, item level, and equip level. It is meant to be used as a library for
other addons which need this information to provide useful functionality. It loads a base database
from the DefaultDatabase file, and then stores any new or different entries in an errata table which
is saved between sessions.


Here is the API, for developers:

In the following descriptions, these terms are defined:
	itemID - A key from the database. A simple positive integer.
	data - A value from the database. Not guaranteed to be the actual value; may just be an index
		into the static database array.


size = ItemBasicInfoDB3.GetDBSize()
	Returns the size of the database.

iterator, state, start = ItemBasicInfoDB3.IterateDB(keysOnly)
	Returns components to iterate over the active database using a "for k, v in iterator, state, start do"
	style of loop. If keysOnly is true, then only the itemID, not the data, will be available for iteration,
	although the iterator will still give a nil value for the second return. This is considerably faster and
	should be used if you do not need the data.

numNew, numUpdated = ItemBasicInfoDB3.CombGetItemInfo(onlyNew)
	Brute-force searches through all possible itemIDs by checking GetItemInfo(), which searches the
	local itemcache.wdb file. The revealed data is then added to the database. This function won't
	disconnect the client, and is actually run once automatically when the library loads. If onlyNew
	is true, the search will only add data, not update it; this is faster.

matcher = ItemBasicInfoDB3.CreateMatcher([itemTypesAndSubtypes][, equipLocs][, minItemLevel][, maxItemLevel][, minEquipLevel][, maxEquipLevel])
	Creates a specially formatted value which can be used with ItemBasicInfoDB3.IsDataMatch() to determine
	whether a given entry in the database is a match. The input itemTypesAndSubtypes, if not nil, should be
	a table of this format:
		[encoded itemType] = true if all subtypes are allowed or {
			[encoded subtype] = true;
		};
	Similarly, the input equipLocs, if not nil, should be a table of this format:
		[encoded equipLoc] = true;

isMatch = ItemBasicInfoDB3.IsDataMatch(data, matcher)
	Given a matcher from ItemBasicInfoDB3.CreateMatcher(), determines whether the given data matches.
	Returns non-nil for a match, or nil for a mismatch.

sorter, identicalTo = ItemBasicInfoDB3.CreateTypeAndSubtypeSorter([indexingKey][, reverse][, skipEquals][, accessDB])
	Creates a function that can be used with a sorting algorithm to sort by type and subtype an array
	subset of the database. If indexingKey is not nil, the function will assume the values given to the
	sorting function are tables and must be indexed with indexingKey to access the ItemBasicInfoDB3
	data for comparison. If reverse is true, the comparison order will be reversed. If skipEquals is true,
	< or > will be used instead of <= or >= (depending on whether reverse is true or not). If accessDB
	is true, the sorter will assume that the values it accesses are actually keys from the database rather
	than the data itself, and it will do the necessary database lookups to get the data. If the identicalTo
	value is not nil, it is a string saying which basic comparator the sorter is identical to (after indexingKey
	is accounted for), either "<", ">", "<=", or ">=".

sorter, identicalTo = ItemBasicInfoDB3.CreateEquipLocSorter([indexingKey][, reverse][, skipEquals][, accessDB])
	Creates a function that can be used with a sorting algorithm to sort by equip location an array subset
	of the database. If indexingKey is not nil, the function will assume the values given to the sorting function
	are tables and must be indexed with indexingKey to access the ItemBasicInfoDB3 data for comparison.
	If reverse is true, the comparison order will be reversed. If skipEquals is true, < or > will be used instead
	of <= or >= (depending on whether reverse is true or not). If accessDB is true, the sorter will assume
	that the values it accesses are actually keys from the database rather than the data itself, and it
	will do the necessary database lookups to get the data. If the identicalTo value is not nil, it is a
	string saying which basic comparator the sorter is identical to (after indexingKey is accounted for),
	either "<", ">", "<=", or ">=".

sorter, identicalTo = ItemBasicInfoDB3.CreateItemLevelSorter([indexingKey][, reverse][, skipEquals][, accessDB])
	Creates a function that can be used with a sorting algorithm to sort by item level an array subset
	of the database. If indexingKey is not nil, the function will assume the values given to the sorting function
	are tables and must be indexed with indexingKey to access the ItemBasicInfoDB3 data for comparison.
	If reverse is true, the comparison order will be reversed. If skipEquals is true, < or > will be used instead
	of <= or >= (depending on whether reverse is true or not). If accessDB is true, the sorter will assume
	that the values it accesses are actually keys from the database rather than the data itself, and it
	will do the necessary database lookups to get the data. If the identicalTo value is not nil, it is a
	string saying which basic comparator the sorter is identical to (after indexingKey is accounted for),
	either "<", ">", "<=", or ">=".

sorter, identicalTo = ItemBasicInfoDB3.CreateEquipLevelSorter([indexingKey][, reverse][, skipEquals][, accessDB])
	Creates a function that can be used with a sorting algorithm to sort by equip level an array subset
	of the database. If indexingKey is not nil, the function will assume the values given to the sorting function
	are tables and must be indexed with indexingKey to access the ItemBasicInfoDB3 data for comparison.
	If reverse is true, the comparison order will be reversed. If skipEquals is true, < or > will be used instead
	of <= or >= (depending on whether reverse is true or not). If accessDB is true, the sorter will assume
	that the values it accesses are actually keys from the database rather than the data itself, and it
	will do the necessary database lookups to get the data. If the identicalTo value is not nil, it is a
	string saying which basic comparator the sorter is identical to (after indexingKey is accounted for),
	either "<", ">", "<=", or ">=".


data = ItemBasicInfoDB3.GetData(itemID)
	Returns the data (value) corresponding to the itemID (key) in the database.

itemType, itemSubtype, equipLoc, itemLevel, equipLevel = ItemBasicInfoDB3.SplitData(data)
	Splits the details from the data and returns them.
	
oldData, newData = ItemBasicInfoDB3.SetData(itemID, newItemType, newItemSubtype, newEquipLoc, newItemLevel, newEquipLevel)
	Sets the database's data for itemID to the combination of the new details. If this new data
	differs from that in the database at the time, it is stored in the errata table.


encoded = ItemBasicInfoDB3.EncodeItemType(itemType[, itemID])
	Given an itemType (as returned from GetItemInfo()), returns an encoded, numeric version of that value.
	If itemID is given, the itemID will be stored in a table for future updating if the itemType is not recognized
	and therefore needs support to be added for it.

itemType = ItemBasicInfoDB3.DecodeItemType(encoded)
	Given a previously encoded itemType value, decodes and returns it.

encoded = ItemBasicInfoDB3.EncodeItemSubtype(itemType, itemSubtype[, itemID])
	Given an itemType (encoded) and an itemSubtype (as returned from GetItemInfo()), returns an encoded,
	numeric version of that value. If itemID is given, the itemID will be stored in a table for future updating if
	the itemSubtype is not recognized and therefore needs support to be added for it.

itemSubtype = ItemBasicInfoDB3.DecodeItemSubtype(itemType, encoded)
	Given a previously encoded itemType and itemSubtype, decodes and returns the itemSubtype.

encoded = ItemBasicInfoDB3.EncodeEquipLoc(equipLoc[, itemID])
	Given an equipLoc (as returned from GetItemInfo()), returns an encoded, numeric version of that value.
	If itemID is given, the itemID will be stored in a table for future updating if the equipLoc is not recognized
	and therefore needs support to be added for it.

equipLoc = ItemBasicInfoDB3.DecodeEquipLoc(encoded)
	Given a previously encoded equipLoc, decodes and returns it.


excluded = ItemBasicInfoDB3.GetTypeExcluded(encodedType)
	Given an encoded itemType, returns whether that type is excluded.
	
ItemBasicInfoDB3.SetTypeExcluded(encodedType, isExcluded)
	Given an encoded itemType, sets whether that type is excluded. This has no immediate
	effect on the database. The UI must be reloaded for existing entries in the database to
	be added or removed based on the new rarity exclusion setting. However, new entries
	in the database will obey the new setting.


minor, subminor = ItemBasicInfoDB3.GetVersion()
	Returns the minor and subminor components of the currently running version of the addon. This is
	the 2 and 3, respectively, of a number like 1.2.3. This is useful if you are depending on the non-embedded
	version of the library.



The library registers some custom events with EventsManager2 which can be used to monitor for new
or updated data:
	ItemBasicInfoDB3_DB_SIZE_CHANGED
		Args:
			1 - The old database size, 0 the first time this fires.
			2 - The new database size.
		Triggers any time an item is added to or removed from the database. Of note is that this
		fires BEFORE the update event for data (except for the first time), so the very next one
		of those will correspond to whatever item was added or removed.
	ItemBasicInfoDB3_ITEM_DATA_CHANGED
		Args:
			1 - itemID
			2 - Old data, potentially nil.
			3 - New data, potentially nil.
		Fires when an item's data changes. The old data will be nil if the item was not in the database.
		The new data will be nil if the item is being removed from the database.


To embed the library into your addon, place the Lib-ItemBasicInfoDB3 directory into your addon's directory.
Then, add the line PATH\ItemBasicInfoDB3_Loader.xml at the top of the file list in your .toc file, such as
Lib-ItemBasicInfoDB3\ItemBasicInfoDB3_Loader.xml. Ensure that all of the required libraries load prior to this.

To run the library non-embedded, require it by listing it in the RequiredDeps line of your .toc file. Then, tell
users to ensure that they always have the latest version installed. To check the running version from your
addon, call the API function ItemBasicInfoDB3.GetVersion().

Either embedded or non-embedded, the saved variables stub should be present in order for errata and
rarity exclusions to be saved. This stub acts just like a normal load-on-demand addon. Your addon does
not need to list it at a dependency.
